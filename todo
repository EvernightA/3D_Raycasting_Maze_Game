-[x]Step 1: Understand the Problem The DDA algorithm -[ ]steps through pixels, giving you quantized positions. For texture sampling, you need the exact mathematical intersection point.

-[x]Step 2: Create calc_exact_hit() function in line_drawing.c

C
#define EPSILON 1e-6f

static void calc_exact_hit(t_hit *hit, t_display *display, float beta)
{
    float ray_dir_x = cosf(display->player.angle + beta);
    float ray_dir_y = sinf(display->player.angle + beta);
    float wall_edge, t;

    // For each wall direction, calculate the exact edge and intersection
    if (hit->wall_direction == WEST && fabsf(ray_dir_x) > EPSILON)
    {
        wall_edge = (hit->collision.x / SIZE_IMG) * SIZE_IMG;
        t = (wall_edge - display->player.pixels.f_x) / ray_dir_x;
        hit->collision.f_x = wall_edge;
        hit->collision.f_y = display->player.pixels.f_y + ray_dir_y * t;
    }
    // Repeat for EAST, NORTH, SOUTH with appropriate edge calculations
}
-[x]Step 3: Modify wall_assign() to call the new function

C
void wall_assign(t_hit *hit, t_line *tmp, t_display *display, float beta)
{
    hit->collision = tmp->dot;
    hit->wall_direction = get_wall_direction(hit->collision, display->player.blocs);
    calc_exact_hit(hit, display, beta);  // Add this line
    hit->distance = to_wall(display, hit->collision, beta);
}
-[x]Step 4: Update to_wall() to use float coordinates Change collision.x → collision.f_x and collision.y → collision.f_y.

-[x]Step 5: Add UV bounds checking in sample_texture()

C
u = fmaxf(0.0f, fminf(1.0f, u));
v = fmaxf(0.0f, fminf(1.0f, v));
-[x]Step 6: Add early return in draw_textured_line()

C
if (line_size <= 0)
    return;
The key math: t = (wall_edge - player_pos) / ray_dir gives you the distance along the ray, then exact_pos = player_pos + ray_dir * t gives the precise intersection point.

New prompt
